import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import paths
from hwo import *

CBF_COLORS = [
    "#5790fc",  # blue
    "#f89c20",  # orange
    "#e42536",  # red
    "#964a8b",  # purple
    "#9c9ca1",  # gray
    "#7a21dd",  # purple
]
import matplotlib as mpl
mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=CBF_COLORS)

def make_dual_cdf_plot(beta_maxes,betas,iwa_list,hab_zones,label_locations,rotations,ax=None,eta_earth=0.24,
                       n_bins=20,savefig=False,filename="accessible_phase_angles.png"):
    '''
    A function that plots the 1-cumulative distribution to show the number of planets that can access a given phase angle
    for a given inner working ange. 

    beta_maxes - An array of maximum scattering angles, generated by the dynamical simulations, shape [n_simulations,n_systems,n_iwas]
    betas - An array of beta values, generated for circular orbits, shape [n_simulations,n_systems,n_iwas]
    iwa_list - list of IWAs you want to use, shape [n_iwas]
    hab_zones - list of habitable zone SMAs in mas, shape [n_systems]
    label_locations - a list of locations for each iwa, shape [n_iwas,2]
    rotations - a list of angles defining the label rotations for each iwa, shape [n_iwas]
    ax - a matplotlib axes on which to plot
    eta_earth - the assumption on the number of systems have interesting planets (basically a scale factor for the y-axis), scalar
    n_bins - the number of bins to use when making hisotgram bins for the cdfs, scalar
    savefig - whether to save the figure or not, boolean
    filename - the filename of the figure you want to save, string
    '''

    #If an axis isn't provided, then make one. 
    if ax is None:
        # fig, axis = plt.subplots(1,1,figsize=(10,4))
        fig, axis = plt.subplots(1,1,figsize=(10,4))
    else: 
        axis=ax

    #Cycle through each IWA to plot a line. 
    for i,iwa in enumerate(iwa_list):
        #### First the dynamical betas.
        # (Although we're calling them betas, really they're the maximum scattering angles)
        
        # Getting data of the histogram bins to build the CDF
        count, bins_count = np.histogram(beta_maxes[:,:,i], bins=np.linspace(90,180,15))
        # finding the PDF of the histogram using count values
        pdf = count / sum(count)
        # using numpy np.cumsum to calculate the CDF
        # We can also find using the PDF values by looping and adding
        cdf = np.cumsum(pdf)

        # Really we want to plot 1-CDF to show the number of systems with a maximum scattering angle less than the Bin
        # We multiply by the number of detected systems (i.e. where the beta_maxes are finite)
        # Then normalize by the number of simulations
        axis.plot(bins_count[1:], (1-cdf)*len(np.where(np.isfinite(beta_maxes[:,:,i]))[0])/beta_maxes[:,:,i].shape[0], color='C{:d}'.format(i),
                linestyle='--',label=r"IWA = {:d} (mas)".format(iwa))

        #### Now the circular case. 
        # (these ones are actually betas.)

        #This is the analytical beta_max for a given iwa. 
        beta_max2 = np.degrees(np.arccos(iwa/(hab_zones)))
        #We need to at 90 to get the maximum scattering angle
        count, bins_count = np.histogram(betas[:,:,i].flatten()+90, bins=np.linspace(90,180,n_bins))
        pdf = count / sum(count)
        cdf = np.cumsum(pdf)

        #Here multiplying by the beta_max takes into account the non-detections and the total number of systems. 
        axis.plot(bins_count[1:], (1-cdf)*np.sum(np.isfinite(beta_max2)),color='C{:d}'.format(i),
                linestyle='-')

        # Add the labels!
        axis.text(label_locations[i][0],label_locations[i][1],r"IWA = {:d} (mas)".format(iwa),color='C{:d}'.format(i),rotation=rotations[i])
    

    
    axis.set_ylabel("Number of systems")
    axis.set_xlabel(r"Accessible phase angles")

    # plt.legend()

    twinx = axis.twiny()
    # twinx.set_label("Minimum phase angle")
    twinx.set_xlim(axis.set_xlim())
    twinx.set_xticks(axis.get_xticks(), labels=[str(x) for x in 90-(axis.get_xticks().astype(int)-90)])
    twinx.set_xlim(axis.set_xlim())
    twinx.set_xlabel("Accessible phase angles")

    yticks = np.arange(0, 180, 20)
    axis.set_yticks(yticks)
    twiny = axis.twinx()
    twiny.set_ylim(axis.set_ylim())
    twiny.set_ylabel(r"Number of planets $\eta_\oplus$={}".format(eta_earth))
    twiny.set_yticks(yticks)
    twiny.set_yticklabels(["{:.0f}".format(x*eta_earth) for x in yticks])
    if savefig: 
        plt.savefig(paths.figures / filename, dpi=200)


if __name__ == "__main__":
    #############
    ### Setup ###
    #############

    ##Read in the ExEP Target List
    df = pd.read_csv(paths.data / '2646_NASA_ExEP_Target_List_HWO_Table.csv')
    #The angular separation of the Earth Equivalent Instellation
    hab_zones = np.array(df['EEIDmas'].values[1:],dtype=float) #in mas

    ##Some Assumed parameters (now imported from hwo.py)
 #   d = 6 #telescope diameter
 #   wavelength = 600e-9

    ## Read in the maximum and minimum scattering angles as 
    ## calculated by the dynamical simulations
    ## This set of files only has 4 IWAs. 
    iwa = np.load(paths.data / 'iwa_all.npz')
    phase_max = iwa['betamax']
    phase_min = iwa['betamin']
    iwa_list =  iwa['iwa']
#    phase_max=np.load(paths.data / "betamax.npy")
#    phase_min=np.load(paths.data / "betamin.npy")
#    iwa_list=np.load(paths.data / "iwa.npy")
    #Note: We only pass phase_max to the plotting routine. 
    # For a given system phase_max and phase_min might differ (with elliptical orbits), 
    # but the distributions mirror each other (about 90 degrees) when you average over enough orbits

    ############################################
    ### Generate betas for the circular case ###
    ############################################

    # The number of random inclinations to generate per system
    n_sims = 1000

    # Beta is an intermediate parameter used here. 
    # The maximum scattering angle is equal to 90+beta degrees
    # The minimum scattering angle is equal to 90-beta degrees
    beta = np.zeros([n_sims,len(hab_zones),len(iwa_list)])

    for i in range(len(hab_zones)):
        #Generate random cos(i)
        incs = np.degrees(np.arccos(np.random.uniform(0.,1,size=n_sims))) 

        #For each target, the absolute maximum scattering angle accessible
        #will be when the _projected_ semi-minor axis of the orbit just 
        #touches the coronagraph inner working angle. 
        for j,iwa in enumerate(iwa_list):
                beta_max0 = np.degrees(np.arccos(iwa/(hab_zones[i])))
                if np.isnan(beta_max0):
                    #if beta_max is nan then the planet is not detectable at this iwa.
                    beta[:,i,j] = np.nan
                else: 
                    #If the inclination is greater than or equal to betamax 
                    # (i.e. if it is touching the coronagraph edge or more), then beta = betamax. 
                    beta[:,i,j] = np.clip(incs,0,beta_max0)

    ##################
    ### Plot Setup ###
    ##################

    #The label locations
    label_locations=[
        [140,83],
        [142,39],
        [120,76],
        [105,70],
    ]

    #The rotation of the labels
    rotations=[
        -27,
        -42,
        -36,
        -25,
    ]

    make_dual_cdf_plot(phase_max,beta,iwa_list,hab_zones,label_locations=label_locations,rotations=rotations,savefig=True)
